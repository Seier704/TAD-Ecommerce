-- --------------------------------------------------------------------------
-- Hola y bienvenido al script de creaci√≥n de nuestro futuro imperio de e-commerce
-- Aqu√≠ se forja el esqueleto de la base de datos.
-- El orden es importante, as√≠ que no te pongas creativo y ejec√∫talo tal cual.
-- --------------------------------------------------------------------------

-- Limpieza previa (bot√≥n de autodestrucci√≥n , cuidadito wasauski)
/*
BEGIN
   FOR c IN (SELECT table_name FROM user_tables) LOOP
      EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name || ' CASCADE CONSTRAINTS';
   END LOOP;
END;
/
*/

-- --------------------------------------------------------------------------

-- Tabla TIENDAS.
CREATE TABLE tiendas (
    tienda_id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre              VARCHAR2(100) NOT NULL,
    url_dominio         VARCHAR2(100),
    fecha_creacion      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_tiendas PRIMARY KEY (tienda_id),
    CONSTRAINT uq_tiendas_nombre UNIQUE (nombre),
    CONSTRAINT uq_tiendas_url UNIQUE (url_dominio)
);
PROMPT Tabla TIENDAS creada.


CREATE TABLE roles (
    rol_id              NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre_rol          VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_roles PRIMARY KEY (rol_id),
    CONSTRAINT uq_roles_nombre UNIQUE (nombre_rol)
);
PROMPT Tabla ROLES creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS.
CREATE TABLE usuarios (
    usuario_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL, -- Cada usuario pertenece a UNA tienda. No hay doble militancia.
    email               VARCHAR2(100) NOT NULL,
    password_hash       VARCHAR2(255) NOT NULL, -- Guardamos el hash, no la pass.
    nombre              VARCHAR2(50),
    apellido            VARCHAR2(50),
    fecha_registro      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_usuarios PRIMARY KEY (usuario_id),
    CONSTRAINT fk_usuarios_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_usuarios_email_tienda UNIQUE (tienda_id, email) -- El email debe ser √∫nico POR tienda.
);

ALTER TABLE usuarios ADD oracle_username VARCHAR2(128);
CREATE UNIQUE INDEX uq_usuarios_oracle_user ON usuarios(oracle_username);
GRANT SELECT ON ECOMMERCE_FRAMEWORK.usuarios TO SYS;



PROMPT Tabla USUARIOS creada.

-- Tabla PRODUCTOS.
CREATE TABLE productos (
    producto_id         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(255) NOT NULL,
    descripcion         CLOB, -- CLOB para descripciones largas, por si nos ponemos po√©ticos.
    precio              NUMBER(10, 2) NOT NULL,
    stock               NUMBER(9) DEFAULT 0 NOT NULL,
    sku                 VARCHAR2(50),
    CONSTRAINT pk_productos PRIMARY KEY (producto_id),
    CONSTRAINT fk_productos_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT chk_productos_precio CHECK (precio > 0), -- No vendemos cosas gratis, esto es un negocio ü§ë.
    CONSTRAINT chk_productos_stock CHECK (stock >= 0),
    CONSTRAINT uq_productos_sku_tienda UNIQUE (tienda_id, sku)
);
PROMPT Tabla PRODUCTOS creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS_ROLES.
-- Esta tabla resuelve la relaci√≥n "Muchos a Muchos". Un usuario puede tener
-- varios roles, y un rol puede tener muchos usuarios. Sin ella, tendr√≠amos un enredo.
CREATE TABLE usuario_roles (
    usuario_id          NUMBER NOT NULL,
    rol_id              NUMBER NOT NULL,
    CONSTRAINT pk_usuario_roles PRIMARY KEY (usuario_id, rol_id),
    CONSTRAINT fk_usuarioroles_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE,
    CONSTRAINT fk_usuarioroles_rol FOREIGN KEY (rol_id) REFERENCES roles(rol_id) ON DELETE CASCADE
);
PROMPT Tabla USUARIO_ROLES creada.

-- Tabla CATEGORIAS.
CREATE TABLE categorias (
    categoria_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(100) NOT NULL,
    descripcion         CLOB,
    CONSTRAINT pk_categorias PRIMARY KEY (categoria_id),
    CONSTRAINT fk_categorias_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_categorias_nombre_tienda UNIQUE (tienda_id, nombre)
);
PROMPT Tabla CATEGORIAS creada.

-- Tabla PRODUCTO_CATEGORIAS.
-- La misma l√≥gica que usuario_roles. Un producto puede estar en varias categor√≠as.
-- Esta tabla es la que nos permite tener una zapatilla en "Ofertas" y "Calzado de Verano".
CREATE TABLE producto_categorias (
    producto_id         NUMBER NOT NULL,
    categoria_id        NUMBER NOT NULL,
    CONSTRAINT pk_producto_categorias PRIMARY KEY (producto_id, categoria_id),
    CONSTRAINT fk_prodcat_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id) ON DELETE CASCADE,
    CONSTRAINT fk_prodcat_categoria FOREIGN KEY (categoria_id) REFERENCES categorias(categoria_id) ON DELETE CASCADE
);
PROMPT Tabla PRODUCTO_CATEGORIAS creada.

-- --------------------------------------------------------------------------
-- Tabla DIRECCIONES.
CREATE TABLE direcciones (
    direccion_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id          NUMBER NOT NULL,
    calle               VARCHAR2(255) NOT NULL,
    ciudad              VARCHAR2(100) NOT NULL,
    region              VARCHAR2(100),
    codigo_postal       VARCHAR2(20),
    pais                VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_direcciones PRIMARY KEY (direccion_id),
    CONSTRAINT fk_direcciones_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE
);
PROMPT Tabla DIRECCIONES creada.

-- Tabla PEDIDOS.
-- LA TABLA M√ÅS IMPORTANTE. Por eso la particionamos.
-- Particionarla por rango de fecha es como organizar un archivador por a√±o.
-- Cuando busquemos un pedido de 2025, Oracle ir√° directo a la carpeta "2025".
-- Inteligente, ¬øno? üßê
CREATE TABLE pedidos (
    pedido_id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id           NUMBER NOT NULL,
    direccion_envio_id   NUMBER,
    fecha_pedido         DATE DEFAULT SYSDATE NOT NULL,
    estado               VARCHAR2(20) NOT NULL,
    total                NUMBER(12, 2) DEFAULT 0 NOT NULL,
    CONSTRAINT pk_pedidos PRIMARY KEY (pedido_id, fecha_pedido),
    CONSTRAINT fk_pedidos_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id),
    CONSTRAINT fk_pedidos_direccion FOREIGN KEY (direccion_envio_id) REFERENCES direcciones(direccion_id) ON DELETE SET NULL,
    CONSTRAINT chk_pedidos_estado CHECK (estado IN ('PENDIENTE', 'PAGADO', 'ENVIADO', 'ENTREGADO', 'CANCELADO'))
)
PARTITION BY RANGE (fecha_pedido)
(
    PARTITION p_pedidos_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_pedidos_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_pedidos_max VALUES LESS THAN (MAXVALUE)
);
PROMPT Tabla PEDIDOS creada y particionada.

-- Tabla DETALLES_PEDIDO.
-- Esta tabla es el detalle de la boleta. Cada producto en un pedido es una fila aqu√≠.
-- As√≠, el pedido y sus detalles siempre estar√°n juntos. üíï
CREATE TABLE detalles_pedido (
    detalle_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    producto_id         NUMBER NOT NULL,
    cantidad            NUMBER(5) NOT NULL,
    precio_unitario     NUMBER(10, 2) NOT NULL, -- Guardamos el precio del momento de la compra. ¬°No hay estafas aqu√≠! üòà
    CONSTRAINT pk_detalles_pedido PRIMARY KEY (detalle_id),
    CONSTRAINT fk_detalles_pedido_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT fk_detalles_pedido_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id)
)
PARTITION BY REFERENCE (fk_detalles_pedido_pedido);
PROMPT Tabla DETALLES_PEDIDO creada y particionada por referencia.

-- Tabla PAGOS.
-- La misma l√≥gica que DETALLES_PEDIDO.
-- Si el pedido est√° en la partici√≥n de 2025, su pago tambi√©n.
CREATE TABLE pagos (
    pago_id             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    monto               NUMBER(12, 2) NOT NULL,
    fecha_pago          DATE DEFAULT SYSDATE NOT NULL,
    metodo_pago         VARCHAR2(50),
    estado_pago         VARCHAR2(20) NOT NULL,
    CONSTRAINT pk_pagos PRIMARY KEY (pago_id),
    CONSTRAINT uq_pagos_pedido UNIQUE (pedido_id, fecha_pedido_fk), -- Un pedido, un pago.
    CONSTRAINT fk_pagos_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT chk_pagos_estado CHECK (estado_pago IN ('COMPLETADO', 'FALLIDO', 'REEMBOLSADO'))
)
PARTITION BY REFERENCE (fk_pagos_pedido);
PROMPT Tabla PAGOS creada y particionada por referencia.

-- DATA WAREHOUSE
-- Aqu√≠ es donde los datos se convierten en GOLD üí∞ 

-- Creacion de la tabla dimensional de tiempo
CREATE TABLE Dim_Tiempo (
    fecha_id         NUMBER PRIMARY KEY,
    fecha            DATE,
    dia              NUMBER,
    mes              NUMBER,
    a√±o              NUMBER,
    trimestre        NUMBER,
    nombre_mes       VARCHAR2(20),
    dia_semana       VARCHAR2(15)
);

PROMPT Dimension de tiempo creada con exito

-- Creacion de la tabla dimensional de producto
CREATE TABLE Dim_Producto (
    producto_id      NUMBER PRIMARY KEY,
    nombre           VARCHAR2(255),
    descripcion      CLOB,
    precio           NUMBER(10,2),
    sku              VARCHAR2(50)
);

PROMPT Dimension de producto creada con exito

-- Creacion de la tabla dimensional de usuario
CREATE TABLE Dim_Usuario (
    usuario_id       NUMBER PRIMARY KEY,
    nombre           VARCHAR2(50),
    apellido         VARCHAR2(50),
    email            VARCHAR2(100),
    tienda_id        NUMBER
);

PROMPT Dimension de usuario creada con exito

-- Creacion de la tabla dimensional de tienda
CREATE TABLE Dim_Tienda (
    tienda_id        NUMBER PRIMARY KEY,
    nombre           VARCHAR2(100),
    url_dominio      VARCHAR2(100),
    fecha_creacion   DATE
);

PROMPT Dimension de tienda creada con exito

--Creacion de tabla de hechos de ventas
CREATE TABLE Hecho_Ventas (
    id_venta         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    fecha_id         NUMBER NOT NULL,
    producto_id      NUMBER NOT NULL,
    usuario_id       NUMBER NOT NULL,
    tienda_id        NUMBER NOT NULL,
    cantidad         NUMBER,
    precio_unitario  NUMBER(10,2),
    total_venta      NUMBER(12,2),
    -- Foreign Keys hacia las dimensiones
    CONSTRAINT fk_hv_tiempo    FOREIGN KEY (fecha_id)    REFERENCES Dim_Tiempo(fecha_id),
    CONSTRAINT fk_hv_producto  FOREIGN KEY (producto_id)  REFERENCES Dim_Producto(producto_id),
    CONSTRAINT fk_hv_usuario   FOREIGN KEY (usuario_id)   REFERENCES Dim_Usuario(usuario_id),
    CONSTRAINT fk_hv_tienda    FOREIGN KEY (tienda_id)    REFERENCES Dim_Tienda(tienda_id)
)
PARTITION BY RANGE (fecha_id)
(
    
    PARTITION p_2024 VALUES LESS THAN (20250101),
    PARTITION p_2025 VALUES LESS THAN (20260101),
    PARTITION p_2026 VALUES LESS THAN (20270101),
    PARTITION p_max  VALUES LESS THAN (MAXVALUE)
);

PROMPT FACTOSSS DE VENTAS CREADOS CON √âXITO ü§ë



-- Se crea la tabla de auditor√≠a
-- Esta tabla registra todas las operaciones de INSERT, UPDATE y DELETE en las tablas principales.
-- Tabla de auditor√≠a (se mantiene igual, solo para referencia)
CREATE TABLE tabla_auditoria (
    auditoria_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre_tabla        VARCHAR2(100) NOT NULL,
    tipo_operacion      VARCHAR2(10) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
    registro_id         NUMBER,                -- ID de la fila afectada en la tabla original
    valores_antiguos    CLOB,                  -- Valores de la fila antes del cambio (para UPDATE/DELETE)
    valores_nuevos      CLOB,                  -- Valores de la fila despu√©s del cambio (para INSERT/UPDATE)
    usuario_accion      VARCHAR2(100) DEFAULT USER NOT NULL, -- Usuario que realiz√≥ la acci√≥n
    fecha_accion        DATE DEFAULT SYSDATE NOT NULL,       -- Marca de tiempo de la acci√≥n
    CONSTRAINT pk_tabla_auditoria PRIMARY KEY (auditoria_id),
    CONSTRAINT chk_tipo_operacion CHECK (tipo_operacion IN ('INSERT', 'UPDATE', 'DELETE'))
)
PARTITION BY RANGE (fecha_accion)
(
    PARTITION p_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_2026 VALUES LESS THAN (TO_DATE('01-01-2027', 'DD-MM-YYYY')),
    PARTITION p_max  VALUES LESS THAN (MAXVALUE)
);

-- Trigger de auditor√≠a para la tabla TIENDAS (CORREGIDO)
CREATE OR REPLACE TRIGGER trg_tiendas_audit
AFTER INSERT OR UPDATE OR DELETE ON tiendas
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
    -- Se intenta obtener el CLIENT_IDENTIFIER.
    -- Si es NULL (ej. para usuarios de sistema), se usa el SESSION_USER.
    v_usuario_accion VARCHAR2(100) := NVL(SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER'), SYS_CONTEXT('USERENV', 'SESSION_USER'));

BEGIN
    IF INSERTING THEN
        -- Para INSERT, los valores antiguos son nulos, los nuevos son los insertados
        v_new_values := 'tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | url_dominio: ' || :NEW.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'INSERT', :NEW.tienda_id, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF UPDATING THEN
        -- Para UPDATE, se registran los valores antiguos y los nuevos
        v_old_values := 'tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | url_dominio: ' || :OLD.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        v_new_values := 'tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | url_dominio: ' || :NEW.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'UPDATE', :NEW.tienda_id, v_old_values, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF DELETING THEN
        -- Para DELETE, solo se registran los valores antiguos (los que fueron eliminados)
        v_old_values := 'tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | url_dominio: ' || :OLD.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'DELETE', :OLD.tienda_id, v_old_values, v_usuario_accion, SYSDATE);
    END IF;
END;
/

PROMPT primer trigger de auditoria creado (tabla tiendas)

-- Trigger para registrar auditor√≠a de la tabla USUARIOS (CORREGIDO)
CREATE OR REPLACE TRIGGER trg_usuarios_audit
AFTER INSERT OR UPDATE OR DELETE ON usuarios
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
    -- Usar NVL para asegurar que siempre haya un valor para usuario_accion
    v_usuario_accion VARCHAR2(100) := NVL(SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER'), SYS_CONTEXT('USERENV', 'SESSION_USER'));
BEGIN
    IF INSERTING THEN
        v_new_values := 'usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | email: ' || :NEW.email ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | apellido: ' || :NEW.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:NEW.fecha_registro, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | oracle_username: ' || :NEW.oracle_username; -- A√±adido oracle_username
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'INSERT', :NEW.usuario_id, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | email: ' || :OLD.email ||
                        ' | password_hash: ' || :OLD.password_hash ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | apellido: ' || :OLD.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:OLD.fecha_registro, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | oracle_username: ' || :OLD.oracle_username; -- A√±adido oracle_username
        v_new_values := 'usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | email: ' || :NEW.email ||
                        ' | password_hash: ' || :NEW.password_hash ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | apellido: ' || :NEW.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:NEW.fecha_registro, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | oracle_username: ' || :NEW.oracle_username; -- A√±adido oracle_username
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'UPDATE', :NEW.usuario_id, v_old_values, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | email: ' || :OLD.email ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | apellido: ' || :OLD.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:OLD.fecha_registro, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | oracle_username: ' || :OLD.oracle_username; -- A√±adido oracle_username
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'DELETE', :OLD.usuario_id, v_old_values, v_usuario_accion, SYSDATE);
    END IF;
END;
/
PROMPT Segundo trigger de auditoria creado (tabla usuarios) ‚úÖ

-- Trigger para registrar auditor√≠a de la tabla PRODUCTOS (CORREGIDO)
CREATE OR REPLACE TRIGGER trg_productos_audit
AFTER INSERT OR UPDATE OR DELETE ON productos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
    -- Usar NVL para asegurar que siempre haya un valor para usuario_accion
    v_usuario_accion VARCHAR2(100) := NVL(SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER'), SYS_CONTEXT('USERENV', 'SESSION_USER'));
BEGIN
    IF INSERTING THEN
        v_new_values := 'producto_id: ' || :NEW.producto_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | descripcion: ' || :NEW.descripcion ||
                        ' | precio: ' || :NEW.precio ||
                        ' | stock: ' || :NEW.stock ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | fecha_actualizacion: ' || TO_CHAR(:NEW.fecha_actualizacion, 'YYYY-MM-DD HH24:MI:SS'); -- Corregido: no hay 'sku'
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('productos', 'INSERT', :NEW.producto_id, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'producto_id: ' || :OLD.producto_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | descripcion: ' || :OLD.descripcion ||
                        ' | precio: ' || :OLD.precio ||
                        ' | stock: ' || :OLD.stock ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | fecha_actualizacion: ' || TO_CHAR(:OLD.fecha_actualizacion, 'YYYY-MM-DD HH24:MI:SS'); -- Corregido: no hay 'sku'
        v_new_values := 'producto_id: ' || :NEW.producto_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | descripcion: ' || :NEW.descripcion ||
                        ' | precio: ' || :NEW.precio ||
                        ' | stock: ' || :NEW.stock ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | fecha_actualizacion: ' || TO_CHAR(:NEW.fecha_actualizacion, 'YYYY-MM-DD HH24:MI:SS'); -- Corregido: no hay 'sku'
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('productos', 'UPDATE', :NEW.producto_id, v_old_values, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'producto_id: ' || :OLD.producto_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | descripcion: ' || :OLD.descripcion ||
                        ' | precio: ' || :OLD.precio ||
                        ' | stock: ' || :OLD.stock ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | fecha_actualizacion: ' || TO_CHAR(:OLD.fecha_actualizacion, 'YYYY-MM-DD HH24:MI:SS'); -- Corregido: no hay 'sku'
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('productos', 'DELETE', :OLD.producto_id, v_old_values, v_usuario_accion, SYSDATE);
    END IF;
END;
/
PROMPT Tercer trigger de auditoria creado (tabla productos) ‚úÖ

-- Trigger para registrar auditor√≠a de la tabla PEDIDOS (CORREGIDO)
CREATE OR REPLACE TRIGGER trg_pedidos_audit
AFTER INSERT OR UPDATE OR DELETE ON pedidos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
    -- Usar NVL para asegurar que siempre haya un valor para usuario_accion
    v_usuario_accion VARCHAR2(100) := NVL(SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER'), SYS_CONTEXT('USERENV', 'SESSION_USER'));
BEGIN
    IF INSERTING THEN
        v_new_values := 'pedido_id: ' || :NEW.pedido_id ||
                        ' | usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id || -- A√±adido tienda_id
                        ' | direccion_envio_id: ' || :NEW.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:NEW.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado_pedido: ' || :NEW.estado_pedido || -- Corregido: estado_pedido
                        ' | total: ' || :NEW.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'INSERT', :NEW.pedido_id, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'pedido_id: ' || :OLD.pedido_id ||
                        ' | usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id || -- A√±adido tienda_id
                        ' | direccion_envio_id: ' || :OLD.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:OLD.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado_pedido: ' || :OLD.estado_pedido || -- Corregido: estado_pedido
                        ' | total: ' || :OLD.total;
        v_new_values := 'pedido_id: ' || :NEW.pedido_id ||
                        ' | usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id || -- A√±adido tienda_id
                        ' | direccion_envio_id: ' || :NEW.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:NEW.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado_pedido: ' || :NEW.estado_pedido || -- Corregido: estado_pedido
                        ' | total: ' || :NEW.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'UPDATE', :NEW.pedido_id, v_old_values, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'pedido_id: ' || :OLD.pedido_id ||
                        ' | usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id || -- A√±adido tienda_id
                        ' | direccion_envio_id: ' || :OLD.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:OLD.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado_pedido: ' || :OLD.estado_pedido || -- Corregido: estado_pedido
                        ' | total: ' || :OLD.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'DELETE', :OLD.pedido_id, v_old_values, v_usuario_accion, SYSDATE);
    END IF;
END;
/
PROMPT Cuarto trigger de auditoria creado (tabla pedidos) ‚úÖ

-- Trigger para registrar auditor√≠a de la tabla DETALLES_PEDIDO (CORREGIDO)
CREATE OR REPLACE TRIGGER trg_detalles_pedido_audit
AFTER INSERT OR UPDATE OR DELETE ON detalles_pedido
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
    -- Usar NVL para asegurar que siempre haya un valor para usuario_accion
    v_usuario_accion VARCHAR2(100) := NVL(SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER'), SYS_CONTEXT('USERENV', 'SESSION_USER'));
BEGIN
    IF INSERTING THEN
        v_new_values := 'detalle_id: ' || :NEW.detalle_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en DETALLES_PEDIDO
                        ' | producto_id: ' || :NEW.producto_id ||
                        ' | cantidad: ' || :NEW.cantidad ||
                        ' | precio_unitario: ' || :NEW.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'INSERT', :NEW.detalle_id, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'detalle_id: ' || :OLD.detalle_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en DETALLES_PEDIDO
                        ' | producto_id: ' || :OLD.producto_id ||
                        ' | cantidad: ' || :OLD.cantidad ||
                        ' | precio_unitario: ' || :OLD.precio_unitario;
        v_new_values := 'detalle_id: ' || :NEW.detalle_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en DETALLES_PEDIDO
                        ' | producto_id: ' || :NEW.producto_id ||
                        ' | cantidad: ' || :NEW.cantidad ||
                        ' | precio_unitario: ' || :NEW.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'UPDATE', :NEW.detalle_id, v_old_values, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'detalle_id: ' || :OLD.detalle_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en DETALLES_PEDIDO
                        ' | producto_id: ' || :OLD.producto_id ||
                        ' | cantidad: ' || :OLD.cantidad ||
                        ' | precio_unitario: ' || :OLD.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'DELETE', :OLD.detalle_id, v_old_values, v_usuario_accion, SYSDATE);
    END IF;
END;
/
PROMPT Quinto trigger de auditoria creado (tabla detalles_pedido) ‚úÖ

-- Trigger para registrar auditor√≠a de la tabla PAGOS (CORREGIDO)
CREATE OR REPLACE TRIGGER trg_pagos_audit
AFTER INSERT OR UPDATE OR DELETE ON pagos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
    -- Usar NVL para asegurar que siempre haya un valor para usuario_accion
    v_usuario_accion VARCHAR2(100) := NVL(SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER'), SYS_CONTEXT('USERENV', 'SESSION_USER'));
BEGIN
    IF INSERTING THEN
        v_new_values := 'pago_id: ' || :NEW.pago_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en PAGOS
                        ' | monto: ' || :NEW.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:NEW.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :NEW.metodo_pago ||
                        ' | estado_pago: ' || :NEW.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pagos', 'INSERT', :NEW.pago_id, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'pago_id: ' || :OLD.pago_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en PAGOS
                        ' | monto: ' || :OLD.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:OLD.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :OLD.metodo_pago ||
                        ' | estado_pago: ' || :OLD.estado_pago;
        v_new_values := 'pago_id: ' || :NEW.pago_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en PAGOS
                        ' | monto: ' || :NEW.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:NEW.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :NEW.metodo_pago ||
                        ' | estado_pago: ' || :NEW.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pagos', 'UPDATE', :NEW.pago_id, v_old_values, v_new_values, v_usuario_accion, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'pago_id: ' || :OLD.pago_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        -- ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') || -- Eliminado: no existe en PAGOS
                        ' | monto: ' || :OLD.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:OLD.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :OLD.metodo_pago ||
                        ' | estado_pago: ' || :OLD.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('pagos', 'DELETE', :OLD.pago_id, v_old_values, v_usuario_accion, SYSDATE);
    END IF;
END;
/
PROMPT Sexto trigger de auditoria creado (tabla pagos) ‚úÖ




---CREACION DE ROLES---
--ROLES:
--      -ADMINISTRADOR: Acceso total
--      -ADMINISTRADOR_TIENDA: Acceso a todas las tablas, pero solo a los datos de su tienda.
--      -VENDEDOR: Acceso limitado a productos y pedidos
--      -BODEGUERO: Manejar el stock, pero sin modificar ventas ni usuarios.
--      -ANALISTA: Realiza SELECTS a distintas tablas
--      -SOPORTE: Acceder a datos de usuarios y pedidos para soporte, sin alterar nada.

CREATE OR REPLACE FUNCTION f_get_tienda_id
RETURN NUMBER IS
  v_id NUMBER;
BEGIN
  SELECT tienda_id INTO v_id
  FROM usuarios
  WHERE email = SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER');
  RETURN v_id;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- PRODUCTOS
CREATE OR REPLACE VIEW v_productos AS
SELECT *
FROM productos
WHERE tienda_id = f_get_tienda_id();

-- CATEGORIAS
CREATE OR REPLACE VIEW v_categorias AS
SELECT *
FROM categorias
WHERE tienda_id = f_get_tienda_id();

-- PEDIDOS (solo los pedidos de usuarios de su tienda)
CREATE OR REPLACE VIEW v_pedidos AS
SELECT p.*
FROM pedidos p
JOIN usuarios u ON p.usuario_id = u.usuario_id
WHERE u.tienda_id = f_get_tienda_id();

-- DETALLES PEDIDO (a trav√©s del pedido ‚Üí usuario ‚Üí tienda)
CREATE OR REPLACE VIEW v_detalles_pedido AS
SELECT dp.*
FROM detalles_pedido dp
JOIN pedidos p ON dp.pedido_id = p.pedido_id AND dp.fecha_pedido_fk = p.fecha_pedido
JOIN usuarios u ON p.usuario_id = u.usuario_id
WHERE u.tienda_id = f_get_tienda_id();

-- PAGOS
CREATE OR REPLACE VIEW v_pagos AS
SELECT pg.*
FROM pagos pg
JOIN pedidos p ON pg.pedido_id = p.pedido_id AND pg.fecha_pedido_fk = p.fecha_pedido
JOIN usuarios u ON p.usuario_id = u.usuario_id
WHERE u.tienda_id = f_get_tienda_id();

-- USUARIOS
CREATE OR REPLACE VIEW v_usuarios AS
SELECT *
FROM usuarios
WHERE tienda_id = f_get_tienda_id();

-- DIRECCIONES
CREATE OR REPLACE VIEW v_direcciones AS
SELECT d.*
FROM direcciones d
JOIN usuarios u ON d.usuario_id = u.usuario_id
WHERE u.tienda_id = f_get_tienda_id();

-- PRODUCTO_CATEGORIAS
CREATE OR REPLACE VIEW v_producto_categorias AS
SELECT pc.*
FROM producto_categorias pc
JOIN productos p ON pc.producto_id = p.producto_id
WHERE p.tienda_id = f_get_tienda_id();

-- USUARIO_ROLES
CREATE OR REPLACE VIEW v_usuario_roles AS
SELECT ur.*
FROM usuario_roles ur
JOIN usuarios u ON ur.usuario_id = u.usuario_id
WHERE u.tienda_id = f_get_tienda_id();

--TIENDAS
CREATE OR REPLACE VIEW v_tiendas AS
SELECT *
FROM tiendas
WHERE tienda_id = f_get_tienda_id();


-- Hecho_Ventas
CREATE OR REPLACE VIEW v_hecho_ventas AS
SELECT *
FROM Hecho_Ventas
WHERE tienda_id = f_get_tienda_id();

-- Solo los productos de mi tienda
CREATE OR REPLACE VIEW v_dim_producto AS
SELECT dp.*
FROM Dim_Producto dp
JOIN productos p ON dp.producto_id = p.producto_id
WHERE p.tienda_id = f_get_tienda_id();

-- Solo los usuarios de mi tienda
CREATE OR REPLACE VIEW v_dim_usuario AS
SELECT *
FROM Dim_Usuario
WHERE tienda_id = f_get_tienda_id();

-- Dim_Tienda con solo mi tienda
CREATE OR REPLACE VIEW v_dim_tienda AS
SELECT *
FROM Dim_Tienda
WHERE tienda_id = f_get_tienda_id();

-- Dim_Tiempo no necesita filtro
CREATE OR REPLACE VIEW v_dim_tiempo AS
SELECT * FROM Dim_Tiempo;

--Tabla de auditor√≠a
CREATE OR REPLACE VIEW v_tabla_auditoria AS
SELECT a.*
FROM tabla_auditoria a
JOIN usuarios u ON u.email = a.usuario_accion
WHERE u.tienda_id = f_get_tienda_id();


CREATE ROLE rol_administrador;
CREATE ROLE rol_administrador_tienda;
CREATE ROLE rol_vendedor;
CREATE ROLE rol_bodeguero;
CREATE ROLE rol_analista;
CREATE ROLE rol_soporte;

-- ADMINISTRADOR
GRANT SELECT, INSERT, UPDATE, DELETE ON tiendas TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON usuarios TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON productos TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON pedidos TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON detalles_pedido TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON pagos TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON categorias TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON producto_categorias TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON direcciones TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON tabla_auditoria TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON usuario_roles TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON roles TO rol_administrador;

GRANT SELECT, INSERT, UPDATE, DELETE ON Dim_Tiempo TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON Dim_Producto TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON Dim_Usuario TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON Dim_Tienda TO rol_administrador;
GRANT SELECT, INSERT, UPDATE, DELETE ON Hecho_Ventas TO rol_administrador;

-- ADMINISTRADOR TIENDA
GRANT SELECT, INSERT, UPDATE, DELETE ON v_tiendas TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_usuarios TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_productos TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_pedidos TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_detalles_pedido TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_pagos TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_categorias TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_producto_categorias TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_direcciones TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_usuario_roles TO rol_administrador_tienda;
GRANT SELECT ON roles TO rol_administrador_tienda;

GRANT SELECT ON v_tabla_auditoria TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_dim_tiempo TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_dim_producto TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_dim_usuario TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_dim_tienda TO rol_administrador_tienda;
GRANT SELECT, INSERT, UPDATE, DELETE ON v_hecho_ventas TO rol_administrador_tienda;

-- VENDEDOR
GRANT SELECT, INSERT, UPDATE ON v_pedidos TO rol_vendedor;
GRANT SELECT, INSERT ON v_detalles_pedido TO rol_vendedor;
GRANT SELECT, INSERT ON v_productos TO rol_vendedor;
GRANT SELECT ON v_usuarios TO rol_vendedor;

-- BODEGUERO
GRANT SELECT ON v_pedidos TO rol_bodeguero;
GRANT SELECT ON v_productos TO rol_bodeguero;
GRANT UPDATE (stock, sku) ON v_productos TO rol_bodeguero;

-- ANALISTA
GRANT SELECT ON v_dim_tiempo TO rol_analista;
GRANT SELECT ON v_dim_producto TO rol_analista;
GRANT SELECT ON v_dim_usuario TO rol_analista;
GRANT SELECT ON v_dim_tienda TO rol_analista;
GRANT SELECT ON v_hecho_ventas TO rol_analista;
GRANT SELECT ON v_tabla_auditoria TO rol_analista;

-- SOPORTE
GRANT SELECT ON v_usuarios TO rol_soporte;
GRANT SELECT ON v_pedidos TO rol_soporte;
GRANT SELECT ON v_pagos TO rol_soporte;
GRANT SELECT ON v_direcciones TO rol_soporte;
GRANT SELECT ON v_usuario_roles TO rol_soporte;

-- USUARIO ADMINISTRADOR
CREATE USER admin_user IDENTIFIED BY admin_pass;
GRANT CONNECT TO admin_user;
ALTER USER admin_user DEFAULT TABLESPACE users;
ALTER USER admin_user QUOTA UNLIMITED ON users;
GRANT rol_administrador TO admin_user;

-- USUARIO ADMINISTRADOR TIENDA
CREATE USER admin_tienda_user IDENTIFIED BY tienda_pass;
GRANT CONNECT TO admin_tienda_user;
ALTER USER admin_tienda_user DEFAULT TABLESPACE users;
ALTER USER admin_tienda_user QUOTA UNLIMITED ON users;
GRANT rol_administrador_tienda TO admin_tienda_user;


-- USUARIO VENDEDOR
CREATE USER vendedor_user IDENTIFIED BY vendedor_pass;
GRANT CONNECT TO vendedor_user;
ALTER USER vendedor_user DEFAULT TABLESPACE users;
ALTER USER vendedor_user QUOTA UNLIMITED ON users;
GRANT rol_vendedor TO vendedor_user;

-- USUARIO BODEGUERO
CREATE USER bodeguero_user IDENTIFIED BY bodeguero_pass;
GRANT CONNECT TO bodeguero_user;
ALTER USER bodeguero_user DEFAULT TABLESPACE users;
ALTER USER bodeguero_user QUOTA UNLIMITED ON users;
GRANT rol_bodeguero TO bodeguero_user;

-- USUARIO ANALISTA
CREATE USER analista_user IDENTIFIED BY analista_pass;
GRANT CONNECT TO analista_user;
ALTER USER analista_user DEFAULT TABLESPACE users;
ALTER USER analista_user QUOTA UNLIMITED ON users;
GRANT rol_analista TO analista_user;

-- USUARIO SOPORTE
CREATE USER soporte_user IDENTIFIED BY soporte_pass;
GRANT CONNECT TO soporte_user;
ALTER USER soporte_user DEFAULT TABLESPACE users;
ALTER USER soporte_user QUOTA UNLIMITED ON users;
GRANT rol_soporte TO soporte_user;

--TRAS CADA INICIO DE SESION SE DEBE EJECUTAR EL SIGUIENTE COMANDO PARA ASIGNAR LA TIENDA ACTUAL
--BEGIN
--  DBMS_SESSION.SET_IDENTIFIER('correo@ejemplo.com');
--END;

PROMPT --- ü§ë ROLES Y USUARIOS CREADOS ü§ë ---

PROMPT --- ü§ë ESTRUCTURA DE BASE DE DATOS CREADA EXITOSAMENTE ü§ë ---
