-- --------------------------------------------------------------------------
-- Hola y bienvenido al script de creaciÃ³n de nuestro futuro imperio de e-commerce
-- AquÃ­ se forja el esqueleto de la base de datos.
-- El orden es importante, asÃ­ que no te pongas creativo y ejecÃºtalo tal cual.
-- --------------------------------------------------------------------------

-- Limpieza previa (botÃ³n de autodestrucciÃ³n , cuidadito wasauski)
/*
BEGIN
   FOR c IN (SELECT table_name FROM user_tables) LOOP
      EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name || ' CASCADE CONSTRAINTS';
   END LOOP;
END;
/
*/

-- --------------------------------------------------------------------------

-- Tabla TIENDAS.
CREATE TABLE tiendas (
    tienda_id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre              VARCHAR2(100) NOT NULL,
    url_dominio         VARCHAR2(100),
    fecha_creacion      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_tiendas PRIMARY KEY (tienda_id),
    CONSTRAINT uq_tiendas_nombre UNIQUE (nombre),
    CONSTRAINT uq_tiendas_url UNIQUE (url_dominio)
);
PROMPT Tabla TIENDAS creada.


CREATE TABLE roles (
    rol_id              NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre_rol          VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_roles PRIMARY KEY (rol_id),
    CONSTRAINT uq_roles_nombre UNIQUE (nombre_rol)
);
PROMPT Tabla ROLES creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS.
CREATE TABLE usuarios (
    usuario_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL, -- Cada usuario pertenece a UNA tienda. No hay doble militancia.
    email               VARCHAR2(100) NOT NULL,
    password_hash       VARCHAR2(255) NOT NULL, -- Guardamos el hash, no la pass.
    nombre              VARCHAR2(50),
    apellido            VARCHAR2(50),
    fecha_registro      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_usuarios PRIMARY KEY (usuario_id),
    CONSTRAINT fk_usuarios_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_usuarios_email_tienda UNIQUE (tienda_id, email) -- El email debe ser Ãºnico POR tienda.
);
PROMPT Tabla USUARIOS creada.

-- Tabla PRODUCTOS.
CREATE TABLE productos (
    producto_id         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(255) NOT NULL,
    descripcion         CLOB, -- CLOB para descripciones largas, por si nos ponemos poÃ©ticos.
    precio              NUMBER(10, 2) NOT NULL,
    stock               NUMBER(9) DEFAULT 0 NOT NULL,
    sku                 VARCHAR2(50),
    CONSTRAINT pk_productos PRIMARY KEY (producto_id),
    CONSTRAINT fk_productos_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT chk_productos_precio CHECK (precio > 0), -- No vendemos cosas gratis, esto es un negocio ðŸ¤‘.
    CONSTRAINT chk_productos_stock CHECK (stock >= 0),
    CONSTRAINT uq_productos_sku_tienda UNIQUE (tienda_id, sku)
);
PROMPT Tabla PRODUCTOS creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS_ROLES.
-- Esta tabla resuelve la relaciÃ³n "Muchos a Muchos". Un usuario puede tener
-- varios roles, y un rol puede tener muchos usuarios. Sin ella, tendrÃ­amos un enredo.
CREATE TABLE usuario_roles (
    usuario_id          NUMBER NOT NULL,
    rol_id              NUMBER NOT NULL,
    CONSTRAINT pk_usuario_roles PRIMARY KEY (usuario_id, rol_id),
    CONSTRAINT fk_usuarioroles_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE,
    CONSTRAINT fk_usuarioroles_rol FOREIGN KEY (rol_id) REFERENCES roles(rol_id) ON DELETE CASCADE
);
PROMPT Tabla USUARIO_ROLES creada.

-- Tabla CATEGORIAS.
CREATE TABLE categorias (
    categoria_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(100) NOT NULL,
    descripcion         CLOB,
    CONSTRAINT pk_categorias PRIMARY KEY (categoria_id),
    CONSTRAINT fk_categorias_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_categorias_nombre_tienda UNIQUE (tienda_id, nombre)
);
PROMPT Tabla CATEGORIAS creada.

-- Tabla PRODUCTO_CATEGORIAS.
-- La misma lÃ³gica que usuario_roles. Un producto puede estar en varias categorÃ­as.
-- Esta tabla es la que nos permite tener una zapatilla en "Ofertas" y "Calzado de Verano".
CREATE TABLE producto_categorias (
    producto_id         NUMBER NOT NULL,
    categoria_id        NUMBER NOT NULL,
    CONSTRAINT pk_producto_categorias PRIMARY KEY (producto_id, categoria_id),
    CONSTRAINT fk_prodcat_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id) ON DELETE CASCADE,
    CONSTRAINT fk_prodcat_categoria FOREIGN KEY (categoria_id) REFERENCES categorias(categoria_id) ON DELETE CASCADE
);
PROMPT Tabla PRODUCTO_CATEGORIAS creada.

-- --------------------------------------------------------------------------
-- Tabla DIRECCIONES.
CREATE TABLE direcciones (
    direccion_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id          NUMBER NOT NULL,
    calle               VARCHAR2(255) NOT NULL,
    ciudad              VARCHAR2(100) NOT NULL,
    region              VARCHAR2(100),
    codigo_postal       VARCHAR2(20),
    pais                VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_direcciones PRIMARY KEY (direccion_id),
    CONSTRAINT fk_direcciones_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE
);
PROMPT Tabla DIRECCIONES creada.

-- Tabla PEDIDOS.
-- LA TABLA MÃS IMPORTANTE. Por eso la particionamos.
-- Particionarla por rango de fecha es como organizar un archivador por aÃ±o.
-- Cuando busquemos un pedido de 2025, Oracle irÃ¡ directo a la carpeta "2025".
-- Inteligente, Â¿no? ðŸ§
CREATE TABLE pedidos (
    pedido_id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id           NUMBER NOT NULL,
    direccion_envio_id   NUMBER,
    fecha_pedido         DATE DEFAULT SYSDATE NOT NULL,
    estado               VARCHAR2(20) NOT NULL,
    total                NUMBER(12, 2) DEFAULT 0 NOT NULL,
    CONSTRAINT pk_pedidos PRIMARY KEY (pedido_id, fecha_pedido),
    CONSTRAINT fk_pedidos_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id),
    CONSTRAINT fk_pedidos_direccion FOREIGN KEY (direccion_envio_id) REFERENCES direcciones(direccion_id) ON DELETE SET NULL,
    CONSTRAINT chk_pedidos_estado CHECK (estado IN ('PENDIENTE', 'PAGADO', 'ENVIADO', 'ENTREGADO', 'CANCELADO'))
)
PARTITION BY RANGE (fecha_pedido)
(
    PARTITION p_pedidos_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_pedidos_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_pedidos_max VALUES LESS THAN (MAXVALUE)
);
PROMPT Tabla PEDIDOS creada y particionada.

-- Tabla DETALLES_PEDIDO.
-- Esta tabla es el detalle de la boleta. Cada producto en un pedido es una fila aquÃ­.
-- AsÃ­, el pedido y sus detalles siempre estarÃ¡n juntos. ðŸ’•
CREATE TABLE detalles_pedido (
    detalle_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    producto_id         NUMBER NOT NULL,
    cantidad            NUMBER(5) NOT NULL,
    precio_unitario     NUMBER(10, 2) NOT NULL, -- Guardamos el precio del momento de la compra. Â¡No hay estafas aquÃ­! ðŸ˜ˆ
    CONSTRAINT pk_detalles_pedido PRIMARY KEY (detalle_id),
    CONSTRAINT fk_detalles_pedido_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT fk_detalles_pedido_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id)
)
PARTITION BY REFERENCE (fk_detalles_pedido_pedido);
PROMPT Tabla DETALLES_PEDIDO creada y particionada por referencia.

-- Tabla PAGOS.
-- La misma lÃ³gica que DETALLES_PEDIDO.
-- Si el pedido estÃ¡ en la particiÃ³n de 2025, su pago tambiÃ©n.
CREATE TABLE pagos (
    pago_id             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    monto               NUMBER(12, 2) NOT NULL,
    fecha_pago          DATE DEFAULT SYSDATE NOT NULL,
    metodo_pago         VARCHAR2(50),
    estado_pago         VARCHAR2(20) NOT NULL,
    CONSTRAINT pk_pagos PRIMARY KEY (pago_id),
    CONSTRAINT uq_pagos_pedido UNIQUE (pedido_id, fecha_pedido_fk), -- Un pedido, un pago.
    CONSTRAINT fk_pagos_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT chk_pagos_estado CHECK (estado_pago IN ('COMPLETADO', 'FALLIDO', 'REEMBOLSADO'))
)
PARTITION BY REFERENCE (fk_pagos_pedido);
PROMPT Tabla PAGOS creada y particionada por referencia.

-- DATA WAREHOUSE
-- AquÃ­ es donde los datos se convierten en GOLD ðŸ’° 

-- Creacion de la tabla dimensional de tiempo
CREATE TABLE Dim_Tiempo (
    fecha_id         NUMBER PRIMARY KEY,
    fecha            DATE,
    dia              NUMBER,
    mes              NUMBER,
    aÃ±o              NUMBER,
    trimestre        NUMBER,
    nombre_mes       VARCHAR2(20),
    dia_semana       VARCHAR2(15)
);

PROMPT Dimension de tiempo creada con exito

-- Creacion de la tabla dimensional de producto
CREATE TABLE Dim_Producto (
    producto_id      NUMBER PRIMARY KEY,
    nombre           VARCHAR2(255),
    descripcion      CLOB,
    precio           NUMBER(10,2),
    sku              VARCHAR2(50)
);

PROMPT Dimension de producto creada con exito

-- Creacion de la tabla dimensional de usuario
CREATE TABLE Dim_Usuario (
    usuario_id       NUMBER PRIMARY KEY,
    nombre           VARCHAR2(50),
    apellido         VARCHAR2(50),
    email            VARCHAR2(100),
    tienda_id        NUMBER
);

PROMPT Dimension de usuario creada con exito

-- Creacion de la tabla dimensional de tienda
CREATE TABLE Dim_Tienda (
    tienda_id        NUMBER PRIMARY KEY,
    nombre           VARCHAR2(100),
    url_dominio      VARCHAR2(100),
    fecha_creacion   DATE
);

PROMPT Dimension de tienda creada con exito

--Creacion de tabla de hechos de ventas
CREATE TABLE Hecho_Ventas (
    id_venta         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    fecha_id         NUMBER NOT NULL,
    fecha           DATE NOT NULL,
    producto_id      NUMBER NOT NULL,
    usuario_id       NUMBER NOT NULL,
    tienda_id        NUMBER NOT NULL,
    cantidad         NUMBER,
    precio_unitario  NUMBER(10,2),
    total_venta      NUMBER(12,2),
    -- Foreign Keys hacia las dimensiones
    CONSTRAINT fk_hv_tiempo    FOREIGN KEY (fecha_id)    REFERENCES Dim_Tiempo(fecha_id),
    CONSTRAINT fk_hv_producto  FOREIGN KEY (producto_id)  REFERENCES Dim_Producto(producto_id),
    CONSTRAINT fk_hv_usuario   FOREIGN KEY (usuario_id)   REFERENCES Dim_Usuario(usuario_id),
    CONSTRAINT fk_hv_tienda    FOREIGN KEY (tienda_id)    REFERENCES Dim_Tienda(tienda_id)
)
PARTITION BY RANGE (fecha)
(
    PARTITION p_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_2026 VALUES LESS THAN (TO_DATE('01-01-2027', 'DD-MM-YYYY')),
    PARTITION p_max  VALUES LESS THAN (MAXVALUE)
);


PROMPT FACTOSSS DE VENTAS CREADOS CON Ã‰XITO ðŸ¤‘



-- Se crea la tabla de auditorÃ­a
-- Esta tabla registra todas las operaciones de INSERT, UPDATE y DELETE en las tablas principales.
CREATE TABLE tabla_auditoria (
    auditoria_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre_tabla        VARCHAR2(100) NOT NULL,
    tipo_operacion      VARCHAR2(10) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
    registro_id         NUMBER,               -- ID de la fila afectada en la tabla original
    valores_antiguos    CLOB,                 -- Valores de la fila antes del cambio (para UPDATE/DELETE)
    valores_nuevos      CLOB,                 -- Valores de la fila despuÃ©s del cambio (para INSERT/UPDATE)
    usuario_accion      VARCHAR2(100) DEFAULT USER NOT NULL, -- Usuario que realizÃ³ la acciÃ³n
    fecha_accion        DATE DEFAULT SYSDATE NOT NULL,      -- Marca de tiempo de la acciÃ³n
    CONSTRAINT pk_tabla_auditoria PRIMARY KEY (auditoria_id),
    CONSTRAINT chk_tipo_operacion CHECK (tipo_operacion IN ('INSERT', 'UPDATE', 'DELETE'))
)
PARTITION BY RANGE (fecha_accion)
(
    PARTITION p_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_2026 VALUES LESS THAN (TO_DATE('01-01-2027', 'DD-MM-YYYY')),
    PARTITION p_max  VALUES LESS THAN (MAXVALUE)
);

PROMPT se crea la tabla auditoria, de aqui vigilamo toh. corte 1984, su gran hermanito


--trigger para ingresar datos de la tabla tiendas a la tabla auditoria
CREATE OR REPLACE TRIGGER trg_tiendas_audit
AFTER INSERT OR UPDATE OR DELETE ON tiendas
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        -- Para INSERT, los valores antiguos son nulos, los nuevos son los insertados
        v_new_values := 'tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | url_dominio: ' || :NEW.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'INSERT', :NEW.tienda_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        -- Para UPDATE, se registran los valores antiguos y los nuevos
        v_old_values := 'tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | url_dominio: ' || :OLD.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        v_new_values := 'tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | url_dominio: ' || :NEW.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'UPDATE', :NEW.tienda_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        -- Para DELETE, solo se registran los valores antiguos (los que fueron eliminados)
        v_old_values := 'tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | url_dominio: ' || :OLD.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'DELETE', :OLD.tienda_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT primer trigger de auditoria creado (tabla tiendas)

-- Trigger para registrar auditorÃ­a de la tabla USUARIOS
CREATE OR REPLACE TRIGGER trg_usuarios_audit
AFTER INSERT OR UPDATE OR DELETE ON usuarios
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;BEGIN
    IF INSERTING THEN
        v_new_values := 'usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | email: ' || :NEW.email ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | apellido: ' || :NEW.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:NEW.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'INSERT', :NEW.usuario_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | email: ' || :OLD.email ||
                        ' | password_hash: ' || :OLD.password_hash ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | apellido: ' || :OLD.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:OLD.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        v_new_values := 'usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | email: ' || :NEW.email ||
                        ' | password_hash: ' || :NEW.password_hash ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | apellido: ' || :NEW.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:NEW.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'UPDATE', :NEW.usuario_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | email: ' || :OLD.email ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | apellido: ' || :OLD.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:OLD.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'DELETE', :OLD.usuario_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Segundo trigger de auditoria creado (tabla usuarios) ðŸ˜”

-- Trigger para registrar auditorÃ­a de la tabla PRODUCTOS
CREATE OR REPLACE TRIGGER trg_productos_audit
AFTER INSERT OR UPDATE OR DELETE ON productos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'producto_id: ' || :NEW.producto_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | descripcion: ' || :NEW.descripcion ||
                        ' | precio: ' || :NEW.precio ||
                        ' | stock: ' || :NEW.stock ||
                        ' | sku: ' || :NEW.sku;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('productos', 'INSERT', :NEW.producto_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'producto_id: ' || :OLD.producto_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | descripcion: ' || :OLD.descripcion ||
                        ' | precio: ' || :OLD.precio ||
                        ' | stock: ' || :OLD.stock ||
                        ' | sku: ' || :OLD.sku;
        v_new_values := 'producto_id: ' || :NEW.producto_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | descripcion: ' || :NEW.descripcion ||
                        ' | precio: ' || :NEW.precio ||
                        ' | stock: ' || :NEW.stock ||
                        ' | sku: ' || :NEW.sku;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('productos', 'UPDATE', :NEW.producto_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'producto_id: ' || :OLD.producto_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | descripcion: ' || :OLD.descripcion ||
                        ' | precio: ' || :OLD.precio ||
                        ' | stock: ' || :OLD.stock ||
                        ' | sku: ' || :OLD.sku;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('productos', 'DELETE', :OLD.producto_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Tercer trigger de auditoria creado (tabla productos) ðŸ˜Ÿ

-- Trigger para registrar auditorÃ­a de la tabla PEDIDOS
CREATE OR REPLACE TRIGGER trg_pedidos_audit
AFTER INSERT OR UPDATE OR DELETE ON pedidos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'pedido_id: ' || :NEW.pedido_id ||
                        ' | usuario_id: ' || :NEW.usuario_id ||
                        ' | direccion_envio_id: ' || :NEW.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:NEW.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :NEW.estado ||
                        ' | total: ' || :NEW.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'INSERT', :NEW.pedido_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'pedido_id: ' || :OLD.pedido_id ||
                        ' | usuario_id: ' || :OLD.usuario_id ||
                        ' | direccion_envio_id: ' || :OLD.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:OLD.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :OLD.estado ||
                        ' | total: ' || :OLD.total;
        v_new_values := 'pedido_id: ' || :NEW.pedido_id ||
                        ' | usuario_id: ' || :NEW.usuario_id ||
                        ' | direccion_envio_id: ' || :NEW.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:NEW.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :NEW.estado ||
                        ' | total: ' || :NEW.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'UPDATE', :NEW.pedido_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'pedido_id: ' || :OLD.pedido_id ||
                        ' | usuario_id: ' || :OLD.usuario_id ||
                        ' | direccion_envio_id: ' || :OLD.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:OLD.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :OLD.estado ||
                        ' | total: ' || :OLD.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'DELETE', :OLD.pedido_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Cuarto trigger de auditoria creado (tabla pedidos) ðŸ¥²


-- Trigger para registrar auditorÃ­a de la tabla DETALLES_PEDIDO
CREATE OR REPLACE TRIGGER trg_detalles_pedido_audit
AFTER INSERT OR UPDATE OR DELETE ON detalles_pedido
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'detalle_id: ' || :NEW.detalle_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :NEW.producto_id ||
                        ' | cantidad: ' || :NEW.cantidad ||
                        ' | precio_unitario: ' || :NEW.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'INSERT', :NEW.detalle_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'detalle_id: ' || :OLD.detalle_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :OLD.producto_id ||
                        ' | cantidad: ' || :OLD.cantidad ||
                        ' | precio_unitario: ' || :OLD.precio_unitario;
        v_new_values := 'detalle_id: ' || :NEW.detalle_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :NEW.producto_id ||
                        ' | cantidad: ' || :NEW.cantidad ||
                        ' | precio_unitario: ' || :NEW.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'UPDATE', :NEW.detalle_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'detalle_id: ' || :OLD.detalle_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :OLD.producto_id ||
                        ' | cantidad: ' || :OLD.cantidad ||
                        ' | precio_unitario: ' || :OLD.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'DELETE', :OLD.detalle_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Quinto trigger de auditoria creado (tabla detalles_pedido) ðŸ˜­ðŸ”«

-- Trigger para registrar auditorÃ­a de la tabla PAGOS
CREATE OR REPLACE TRIGGER trg_pagos_audit
AFTER INSERT OR UPDATE OR DELETE ON pagos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'pago_id: ' || :NEW.pago_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :NEW.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:NEW.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :NEW.metodo_pago ||
                        ' | estado_pago: ' || :NEW.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, USER, fecha_accion)
        VALUES ('pagos', 'INSERT', :NEW.pago_id, v_new_values, v_usuario_app, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'pago_id: ' || :OLD.pago_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :OLD.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:OLD.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :OLD.metodo_pago ||
                        ' | estado_pago: ' || :OLD.estado_pago;
        v_new_values := 'pago_id: ' || :NEW.pago_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :NEW.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:NEW.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :NEW.metodo_pago ||
                        ' | estado_pago: ' || :NEW.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, USER, fecha_accion)
        VALUES ('pagos', 'UPDATE', :NEW.pago_id, v_old_values, v_new_values, v_usuario_app, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'pago_id: ' || :OLD.pago_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :OLD.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:OLD.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :OLD.metodo_pago ||
                        ' | estado_pago: ' || :OLD.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, USER, fecha_accion)
        VALUES ('pagos', 'DELETE', :OLD.pago_id, v_old_values, v_usuario_app, SYSDATE);
    END IF;
END;
/

PROMPT Sexto trigger de auditoria creado (tabla pagos) ðŸ’€


-- CreaciÃ³n de los roles especÃ­ficos para las tiendas
CREATE ROLE admin_tienda_role;
CREATE ROLE bodeguero_role;
CREATE ROLE vendedor_role;

PROMPT Roles creados: admin_tienda_role, bodeguero_role, vendedor_role.

-- --------------------------------------------------------------------------
-- Privilegios para el Administrador de la Tienda (casi control total sobre su tienda)
-- --------------------------------------------------------------------------
GRANT SELECT, INSERT, UPDATE, DELETE ON productos TO admin_tienda_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON categorias TO admin_tienda_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON pedidos TO admin_tienda_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON detalles_pedido TO admin_tienda_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON pagos TO admin_tienda_role;
GRANT SELECT, INSERT, UPDATE ON usuarios TO admin_tienda_role; -- No puede eliminar otros usuarios, pero sÃ­ gestionarlos
GRANT SELECT, INSERT, DELETE ON usuario_roles TO admin_tienda_role; -- Puede asignar roles a sus usuarios
GRANT SELECT ON tiendas TO admin_tienda_role; -- Puede ver la info de su tienda

-- --------------------------------------------------------------------------
-- Privilegios para el Bodeguero (gestiÃ³n de inventario y pedidos)
-- --------------------------------------------------------------------------
GRANT SELECT, UPDATE(stock, descripcion) ON productos TO bodeguero_role;
GRANT SELECT ON pedidos TO bodeguero_role;
GRANT SELECT ON detalles_pedido TO bodeguero_role;

-- --------------------------------------------------------------------------
-- Privilegios para el Vendedor (creaciÃ³n de pedidos)
-- --------------------------------------------------------------------------
GRANT SELECT ON productos TO vendedor_role;
GRANT SELECT ON categorias TO vendedor_role;
GRANT SELECT, INSERT ON pedidos TO vendedor_role;
GRANT SELECT, INSERT ON detalles_pedido TO vendedor_role;
GRANT SELECT, INSERT ON pagos TO vendedor_role;
GRANT SELECT, INSERT ON direcciones TO vendedor_role;

PROMPT Privilegios bÃ¡sicos asignados a los roles.

-- Creamos un contexto para almacenar de forma segura el ID de la tienda del usuario.
CREATE OR REPLACE CONTEXT contexto_tienda USING pkg_seguridad_tienda;

PROMPT Contexto 'contexto_tienda' creado.

CREATE OR REPLACE PACKAGE pkg_seguridad_tienda IS
    -- Procedimiento que se ejecuta al iniciar sesiÃ³n para establecer el contexto.
    PROCEDURE sp_set_tienda_context;

    -- FunciÃ³n que genera la condiciÃ³n WHERE para las polÃ­ticas de VPD.
    FUNCTION fn_politica_acceso_tienda(
        p_schema IN VARCHAR2,
        p_object IN VARCHAR2
    ) RETURN VARCHAR2;
END pkg_seguridad_tienda;
/

CREATE OR REPLACE PACKAGE BODY pkg_seguridad_tienda IS
    PROCEDURE sp_set_tienda_context IS
        v_tienda_id NUMBER;
        v_user      VARCHAR2(100) := SYS_CONTEXT('USERENV', 'SESSION_USER');
    BEGIN
        -- Buscamos la tienda a la que pertenece el usuario.
        -- Se asume que el nombre de usuario de la BD es el email en la tabla USUARIOS.
        BEGIN
            SELECT tienda_id INTO v_tienda_id
            FROM usuarios
            WHERE email = v_user;

            -- Establecemos el valor en el contexto de la sesiÃ³n.
            DBMS_SESSION.SET_CONTEXT('contexto_tienda', 'tienda_id', v_tienda_id);
        EXCEPTION
            -- Si el usuario no estÃ¡ en la tabla (ej. SYS, SYSTEM), no se establece el contexto.
            WHEN NO_DATA_FOUND THEN
                NULL;
        END;
    END sp_set_tienda_context;

    FUNCTION fn_politica_acceso_tienda(
        p_schema IN VARCHAR2,
        p_object IN VARCHAR2
    ) RETURN VARCHAR2 IS
        v_tienda_id NUMBER;
    BEGIN
        -- Obtenemos el ID de la tienda desde el contexto.
        v_tienda_id := SYS_CONTEXT('contexto_tienda', 'tienda_id');

        -- Si el usuario tiene un tienda_id asociado, aplicamos el filtro.
        IF v_tienda_id IS NOT NULL THEN
            -- Retorna la clÃ¡usula WHERE que se aÃ±adirÃ¡ dinÃ¡micamente.
            RETURN 'tienda_id = ' || v_tienda_id;
        ELSE
            -- Si el usuario no tiene tienda_id (es un superusuario como SYS),
            -- o es un usuario que no debe ser filtrado, no se aplica la polÃ­tica.
            -- Devolver '1=1' permite ver todo.
            -- Para mayor seguridad, podrÃ­a ser '1=0' para no ver nada.
            RETURN '1=1';
        END IF;
    END fn_politica_acceso_tienda;
END pkg_seguridad_tienda;
/

-- Trigger que se dispara despuÃ©s de que un usuario inicie sesiÃ³n en la BD.
CREATE OR REPLACE TRIGGER trg_set_tienda_context
AFTER LOGON ON DATABASE
BEGIN
    -- Llama al procedimiento para establecer el contexto.
    pkg_seguridad_tienda.sp_set_tienda_context;
END;
/

PROMPT Paquete de seguridad y trigger de logon creados con Ã©xito.

-- Ahora aplicamos las polÃ­ticas de VPD a las tablas principales.
BEGIN
    DBMS_RLS.ADD_POLICY(
        object_schema => USER,
        object_name   => 'productos',
        policy_name   => 'politica_productos_tienda',
        function_schema => USER,
        policy_function => 'pkg_seguridad_tienda.fn_politica_acceso_tienda',
        statement_types => 'SELECT, INSERT, UPDATE, DELETE',
        update_check   => TRUE
    );

    DBMS_RLS.ADD_POLICY(
        object_schema => USER,
        object_name   => 'usuarios',
        policy_name   => 'politica_usuarios_tienda',
        function_schema => USER,
        policy_function => 'pkg_seguridad_tienda.fn_politica_acceso_tienda',
        statement_types => 'SELECT, INSERT, UPDATE, DELETE',
        update_check   => TRUE
    );

    DBMS_RLS.ADD_POLICY(
        object_schema => USER,
        object_name   => 'categorias',
        policy_name   => 'politica_categorias_tienda',
        function_schema => USER,
        policy_function => 'pkg_seguridad_tienda.fn_politica_acceso_tienda',
        statement_types => 'SELECT, INSERT, UPDATE, DELETE',
        update_check   => TRUE
    );
END;
/

PROMPT PolÃ­ticas de VPD aplicadas a las tablas principales.


-- 1. Crear dos tiendas para demostrar el aislamiento
INSERT INTO tiendas (tienda_id, nombre, url_dominio) VALUES (1, 'Mi Tienda de Prueba', 'mitienda.test');
INSERT INTO tiendas (tienda_id, nombre, url_dominio) VALUES (2, 'La Competencia Secreta', 'secreto.test');
PROMPT -> Tiendas de ejemplo creadas.

-- 2. Crear un producto para CADA tienda
INSERT INTO productos (tienda_id, nombre, precio, stock, sku)
VALUES (1, 'Laptop Pro', 1200.50, 50, 'LP-PRO-1');

INSERT INTO productos (tienda_id, nombre, precio, stock, sku)
VALUES (2, 'Smartphone X', 899.99, 150, 'SP-X-2');
PROMPT -> Productos de ejemplo creados para cada tienda.

-- 3. Crear el registro del usuario en la tabla de la aplicaciÃ³n
-- Este usuario pertenecerÃ¡ a la tienda con tienda_id = 1
INSERT INTO usuarios (tienda_id, email, password_hash, nombre, apellido)
VALUES (1, 'vendedor.prueba@tienda.local', 'un_hash_cualquiera', 'Juan', 'Vendedor');
PROMPT -> Registro de usuario de prueba insertado en la tabla de usuarios.
COMMIT;

-- 4. Crear el usuario en la Base de Datos Oracle
-- El nombre de usuario DEBE coincidir con el email
-- Si el usuario ya existe, esta lÃ­nea darÃ¡ error. Puedes ignorarlo o hacer un DROP USER antes.
CREATE USER "vendedor.prueba@tienda.local" IDENTIFIED BY "VendedorPass123";
PROMPT -> Usuario de base de datos 'vendedor.prueba@tienda.local' creado.

-- 5. Asignar permisos bÃ¡sicos y el rol de vendedor
GRANT CONNECT, RESOURCE TO "vendedor.prueba@tienda.local";
GRANT vendedor_role TO "vendedor.prueba@tienda.local";
ALTER USER "vendedor.prueba@tienda.local" DEFAULT ROLE vendedor_role;
PROMPT -> Permisos y rol 'vendedor_role' asignados. Â¡Listo para probar!

EXIT;

-- si inicias sesiÃ³n con el usuario
-- sqlplus "vendedor.prueba@tienda.local"/"VendedorPass123"@//localhost:1521/XEPDB1

-- y hacemos este select, deberÃ­as ver solo el producto de tu tienda:
-- SELECT producto_id, nombre, precio, tienda_id FROM ECOMMERCE_FRAMEWORK.productos;

--  PRODUCTO_ID NOMBRE          PRECIO  TIENDA_ID
--  ----------- ------------ --------- ----------
--          1 Laptop Pro      1200.5          1

-- y si hace esto
--UPDATE ECOMMERCE_FRAMEWORK.productos SET stock = 49 WHERE producto_id = 1;
-- deberia lanzar
-- ORA-01031: insufficient privileges

--si intenta ver datos de otra tienda 
-- SELECT * FROM ECOMMERCE_FRAMEWORK.productos WHERE producto_id = 2;
-- deberia lanzar
-- no rows selected

COMMIT;

PROMPT --- ðŸ¤‘ ROLES Y USUARIOS CREADOS ðŸ¤‘ ---

PROMPT --- ðŸ¤‘ ESTRUCTURA DE BASE DE DATOS CREADA EXITOSAMENTE ðŸ¤‘ ---
